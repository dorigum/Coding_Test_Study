
// 프로그래머스 코딩테스트 연습
// 깊이/너비 우선 탐색(DFS/BFS)
// 타겟 넘버(Level 2)

// 💡 코드 설명 요약
// 1. solution()
// (1) DFS를 시작해서 경우의 수를 탐색하고, 최종적으로 temp에 누적된 값을 반환합니다.

// 2. dfs()
// (1) depth: 현재 탐색한 깊이 (numbers 배열에서 몇 번째 원소까지 썼는지)
// (2) sum: 현재까지 선택한 숫자들의 합
// (3) 배열 끝까지 탐색했을 때 sum == target이면 temp를 1 증가시킵니다.
// (4) 그렇지 않으면, 현재 숫자를 +로 더한 경우와 -로 뺀 경우를 재귀적으로 탐색합니다.

import java.util.*;

class Solution {
    // 타겟 넘버를 만들 수 있는 경우의 수를 저장하는 변수
    static int temp;
    
    public int solution(int[] numbers, int target) {
        // sum은 DFS에서 현재까지의 합을 의미할 변수
        int sum = 0;
        // answer는 최종 결과(방법의 수)를 반환하기 위한 변수
        int answer = sum;
        
        // DFS 탐색 시작 (배열, 타겟, 현재 깊이=0, 현재 합=0)
        dfs(numbers, target, 0, 0);
        // temp에 DFS 탐색 결과가 누적되어 저장됨
        answer = temp;
        
        return answer;  // 타겟 넘버를 만들 수 있는 경우의 수 반환
    }
    
    // DFS 탐색 메서드
    static void dfs(int[] numbers, int target, int depth, int sum) {
        // 종료 조건: 모든 숫자를 다 사용한 경우
        if(numbers.length == depth) {
            // 합계가 타겟과 같으면 경우의 수 증가
            if(target == sum) {
                temp += 1;
            }
        } else {
            // 현재 숫자를 +로 더하는 경우
            dfs(numbers, target, depth+1, sum + numbers[depth]);
            // 현재 숫자를 -로 빼는 경우
            dfs(numbers, target, depth+1, sum - numbers[depth]);
        }
    }
}
